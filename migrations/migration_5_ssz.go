package migrations

import (
	"fmt"

	ssz "github.com/ferranbt/fastssz"
	"github.com/ssvlabs/ssv/protocol/v2/types"
)

var sharesPrefixSSZ = []byte("shares_ssz/")

const addressLength = 20

// storageShareSSZ represents a Share stored in DB. SSZ encodings generator has some limitations
// in terms of what types it supports, hence we define a bunch of own types here to satisfy it,
// see more on this here: https://github.com/ferranbt/fastssz/issues/179#issuecomment-2454371820
type storageShareSSZ struct {
	ValidatorIndex        uint64
	ValidatorPubKey       []byte                `ssz-size:"48"`
	SharePubKey           []byte                `ssz-max:"48"` // empty for not own shares
	Committee             []*storageOperatorSSZ `ssz-max:"13"`
	Quorum, PartialQuorum uint64
	DomainType            [4]byte `ssz-size:"4"`
	FeeRecipientAddress   [addressLength]byte
	Graffiti              []byte `ssz-max:"32"`

	Status          uint64
	ActivationEpoch uint64
	OwnerAddress    [addressLength]byte
	Liquidated      bool
}

type storageOperatorSSZ struct {
	OperatorID uint64
	PubKey     []byte `ssz-max:"48"`
}

// Encode encodes Share using ssz.
func (s *storageShareSSZ) Encode() ([]byte, error) {
	result, err := s.MarshalSSZ()
	if err != nil {
		return nil, fmt.Errorf("marshal ssz: %w", err)
	}
	return result, nil
}

// Decode decodes Share using ssz.
func (s *storageShareSSZ) Decode(data []byte) error {
	if len(data) > types.MaxAllowedShareSize {
		return fmt.Errorf("share size is too big, got %v, max allowed %v", len(data), types.MaxAllowedShareSize)
	}
	if err := s.UnmarshalSSZ(data); err != nil {
		return fmt.Errorf("decode storageShareSSZ: %w", err)
	}
	s.Quorum, s.PartialQuorum = types.ComputeQuorumAndPartialQuorum(uint64(len(s.Committee)))
	return nil
}

func specShareToStorageShareSSZ(share *types.SSVShare) *storageShareSSZ {
	committee := make([]*storageOperatorSSZ, len(share.Committee))
	for i, c := range share.Committee {
		committee[i] = &storageOperatorSSZ{
			OperatorID: c.Signer,
			PubKey:     c.SharePubKey,
		}
	}
	quorum, partialQuorum := types.ComputeQuorumAndPartialQuorum(uint64(len(committee)))
	return &storageShareSSZ{
		ValidatorIndex:      uint64(share.ValidatorIndex),
		ValidatorPubKey:     share.ValidatorPubKey[:],
		SharePubKey:         share.SharePubKey,
		Committee:           committee,
		Quorum:              quorum,
		PartialQuorum:       partialQuorum,
		DomainType:          share.DomainType,
		FeeRecipientAddress: share.FeeRecipientAddress,
		Graffiti:            share.Graffiti,
		OwnerAddress:        share.OwnerAddress,
		Liquidated:          share.Liquidated,
		Status:              uint64(share.Status), // nolint: gosec
		ActivationEpoch:     uint64(share.ActivationEpoch),
	}
}

// storageKeySSZ builds share key using sharesPrefix & validator public key, e.g. "shares_ssz/0x00..01"
func storageKeySSZ(pk []byte) []byte {
	return append(sharesPrefixSSZ, pk...)
}

// Code generated by fastssz. DO NOT EDIT.
// Hash: 42489121add47f54f3dbbaafd9eb71f5236dbb074217e5d16cf2514b59c1b809
// Version: 0.1.3

// MarshalSSZ ssz marshals the storageShareSSZ object
func (s *storageShareSSZ) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the storageShareSSZ object to a target array
func (s *storageShareSSZ) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(129)

	// Field (0) 'ValidatorIndex'
	dst = ssz.MarshalUint64(dst, s.ValidatorIndex)

	// Field (1) 'ValidatorPubKey'
	if size := len(s.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("storageShareSSZ.ValidatorPubKey", size, 48)
		return
	}
	dst = append(dst, s.ValidatorPubKey...)

	// Offset (2) 'SharePubKey'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.SharePubKey)

	// Offset (3) 'Committee'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(s.Committee); ii++ {
		offset += 4
		offset += s.Committee[ii].SizeSSZ()
	}

	// Field (4) 'DomainType'
	dst = append(dst, s.DomainType[:]...)

	// Field (5) 'FeeRecipientAddress'
	dst = append(dst, s.FeeRecipientAddress[:]...)

	// Offset (6) 'Graffiti'
	dst = ssz.WriteOffset(dst, offset)

	// Field (7) 'Status'
	dst = ssz.MarshalUint64(dst, s.Status)

	// Field (8) 'ActivationEpoch'
	dst = ssz.MarshalUint64(dst, s.ActivationEpoch)

	// Field (9) 'OwnerAddress'
	dst = append(dst, s.OwnerAddress[:]...)

	// Field (10) 'Liquidated'
	dst = ssz.MarshalBool(dst, s.Liquidated)

	// Field (2) 'SharePubKey'
	if size := len(s.SharePubKey); size > 48 {
		err = ssz.ErrBytesLengthFn("storageShareSSZ.SharePubKey", size, 48)
		return
	}
	dst = append(dst, s.SharePubKey...)

	// Field (3) 'Committee'
	if size := len(s.Committee); size > 13 {
		err = ssz.ErrListTooBigFn("storageShareSSZ.Committee", size, 13)
		return
	}
	{
		offset = 4 * len(s.Committee)
		for ii := 0; ii < len(s.Committee); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += s.Committee[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(s.Committee); ii++ {
		if dst, err = s.Committee[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (6) 'Graffiti'
	if size := len(s.Graffiti); size > 32 {
		err = ssz.ErrBytesLengthFn("storageShareSSZ.Graffiti", size, 32)
		return
	}
	dst = append(dst, s.Graffiti...)

	return
}

// UnmarshalSSZ ssz unmarshals the storageShareSSZ object
func (s *storageShareSSZ) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 129 {
		return ssz.ErrSize
	}

	tail := buf
	var o2, o3, o6 uint64

	// Field (0) 'ValidatorIndex'
	s.ValidatorIndex = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'ValidatorPubKey'
	if cap(s.ValidatorPubKey) == 0 {
		s.ValidatorPubKey = make([]byte, 0, len(buf[8:56]))
	}
	s.ValidatorPubKey = append(s.ValidatorPubKey, buf[8:56]...)

	// Offset (2) 'SharePubKey'
	if o2 = ssz.ReadOffset(buf[56:60]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 != 129 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (3) 'Committee'
	if o3 = ssz.ReadOffset(buf[60:64]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'DomainType'
	copy(s.DomainType[:], buf[64:68])

	// Field (5) 'FeeRecipientAddress'
	copy(s.FeeRecipientAddress[:], buf[68:88])

	// Offset (6) 'Graffiti'
	if o6 = ssz.ReadOffset(buf[88:92]); o6 > size || o3 > o6 {
		return ssz.ErrOffset
	}

	// Field (7) 'Status'
	s.Status = ssz.UnmarshallUint64(buf[92:100])

	// Field (8) 'ActivationEpoch'
	s.ActivationEpoch = ssz.UnmarshallUint64(buf[100:108])

	// Field (9) 'OwnerAddress'
	copy(s.OwnerAddress[:], buf[108:128])

	// Field (10) 'Liquidated'
	s.Liquidated = ssz.UnmarshalBool(buf[128:129])

	// Field (2) 'SharePubKey'
	{
		buf = tail[o2:o3]
		if len(buf) > 48 {
			return ssz.ErrBytesLength
		}
		if cap(s.SharePubKey) == 0 {
			s.SharePubKey = make([]byte, 0, len(buf))
		}
		s.SharePubKey = append(s.SharePubKey, buf...)
	}

	// Field (3) 'Committee'
	{
		buf = tail[o3:o6]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		s.Committee = make([]*storageOperatorSSZ, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if s.Committee[indx] == nil {
				s.Committee[indx] = new(storageOperatorSSZ)
			}
			if err = s.Committee[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (6) 'Graffiti'
	{
		buf = tail[o6:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(s.Graffiti) == 0 {
			s.Graffiti = make([]byte, 0, len(buf))
		}
		s.Graffiti = append(s.Graffiti, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the storageShareSSZ object
func (s *storageShareSSZ) SizeSSZ() (size int) {
	size = 129

	// Field (2) 'SharePubKey'
	size += len(s.SharePubKey)

	// Field (3) 'Committee'
	for ii := 0; ii < len(s.Committee); ii++ {
		size += 4
		size += s.Committee[ii].SizeSSZ()
	}

	// Field (6) 'Graffiti'
	size += len(s.Graffiti)

	return
}

// HashTreeRoot ssz hashes the storageShareSSZ object
func (s *storageShareSSZ) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the storageShareSSZ object with a hasher
func (s *storageShareSSZ) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorIndex'
	hh.PutUint64(s.ValidatorIndex)

	// Field (1) 'ValidatorPubKey'
	if size := len(s.ValidatorPubKey); size != 48 {
		err = ssz.ErrBytesLengthFn("storageShareSSZ.ValidatorPubKey", size, 48)
		return
	}
	hh.PutBytes(s.ValidatorPubKey)

	// Field (2) 'SharePubKey'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.SharePubKey))
		if byteLen > 48 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.SharePubKey)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (48+31)/32)
	}

	// Field (3) 'Committee'
	{
		subIndx := hh.Index()
		num := uint64(len(s.Committee))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range s.Committee {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'DomainType'
	hh.PutBytes(s.DomainType[:])

	// Field (5) 'FeeRecipientAddress'
	hh.PutBytes(s.FeeRecipientAddress[:])

	// Field (6) 'Graffiti'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.Graffiti))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.Graffiti)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (7) 'Status'
	hh.PutUint64(s.Status)

	// Field (8) 'ActivationEpoch'
	hh.PutUint64(s.ActivationEpoch)

	// Field (9) 'OwnerAddress'
	hh.PutBytes(s.OwnerAddress[:])

	// Field (10) 'Liquidated'
	hh.PutBool(s.Liquidated)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the storageShareSSZ object
func (s *storageShareSSZ) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the storageOperatorSSZ object
func (s *storageOperatorSSZ) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the storageOperatorSSZ object to a target array
func (s *storageOperatorSSZ) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Field (0) 'OperatorID'
	dst = ssz.MarshalUint64(dst, s.OperatorID)

	// Offset (1) 'PubKey'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'PubKey'
	if size := len(s.PubKey); size > 48 {
		err = ssz.ErrBytesLengthFn("storageOperatorSSZ.PubKey", size, 48)
		return
	}
	dst = append(dst, s.PubKey...)

	return
}

// UnmarshalSSZ ssz unmarshals the storageOperatorSSZ object
func (s *storageOperatorSSZ) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'OperatorID'
	s.OperatorID = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'PubKey'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 != 12 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'PubKey'
	{
		buf = tail[o1:]
		if len(buf) > 48 {
			return ssz.ErrBytesLength
		}
		if cap(s.PubKey) == 0 {
			s.PubKey = make([]byte, 0, len(buf))
		}
		s.PubKey = append(s.PubKey, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the storageOperatorSSZ object
func (s *storageOperatorSSZ) SizeSSZ() (size int) {
	size = 12

	// Field (1) 'PubKey'
	size += len(s.PubKey)

	return
}

// HashTreeRoot ssz hashes the storageOperatorSSZ object
func (s *storageOperatorSSZ) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the storageOperatorSSZ object with a hasher
func (s *storageOperatorSSZ) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'OperatorID'
	hh.PutUint64(s.OperatorID)

	// Field (1) 'PubKey'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.PubKey))
		if byteLen > 48 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.PubKey)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (48+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the storageOperatorSSZ object
func (s *storageOperatorSSZ) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
