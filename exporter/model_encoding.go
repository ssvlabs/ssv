// Code generated by fastssz. DO NOT EDIT.
// Hash: 7d788e9f9e0a9cf87be19bceb047e674cb76a268374555481c6aabee547a3de2
// Version: 0.1.3
package exporter

import (
	"github.com/attestantio/go-eth2-client/spec/phase0"
	ssz "github.com/ferranbt/fastssz"

	spectypes "github.com/ssvlabs/ssv-spec/types"
)

// MarshalSSZ ssz marshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the ValidatorDutyTrace object to a target array
func (v *ValidatorDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(44)

	// Offset (0) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(v.Rounds); ii++ {
		offset += 4
		offset += v.Rounds[ii].SizeSSZ()
	}

	// Offset (1) 'Decideds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(v.Decideds); ii++ {
		offset += 4
		offset += v.Decideds[ii].SizeSSZ()
	}

	// Field (2) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(v.Slot))

	// Field (3) 'Role'
	dst = ssz.MarshalUint64(dst, uint64(v.Role))

	// Field (4) 'Validator'
	dst = ssz.MarshalUint64(dst, uint64(v.Validator))

	// Offset (5) 'ProposalData'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.ProposalData)

	// Offset (6) 'Pre'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Pre) * 56

	// Offset (7) 'Post'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(v.Post) * 56

	// Field (0) 'Rounds'
	if size := len(v.Rounds); size > 15 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Rounds", size, 15)
		return
	}
	{
		offset = 4 * len(v.Rounds)
		for ii := 0; ii < len(v.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += v.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(v.Rounds); ii++ {
		if dst, err = v.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Decideds'
	if size := len(v.Decideds); size > 256 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Decideds", size, 256)
		return
	}
	{
		offset = 4 * len(v.Decideds)
		for ii := 0; ii < len(v.Decideds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += v.Decideds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(v.Decideds); ii++ {
		if dst, err = v.Decideds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'ProposalData'
	if size := len(v.ProposalData); size > 4194532 {
		err = ssz.ErrBytesLengthFn("ValidatorDutyTrace.ProposalData", size, 4194532)
		return
	}
	dst = append(dst, v.ProposalData...)

	// Field (6) 'Pre'
	if size := len(v.Pre); size > 13 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Pre", size, 13)
		return
	}
	for ii := 0; ii < len(v.Pre); ii++ {
		if dst, err = v.Pre[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'Post'
	if size := len(v.Post); size > 13 {
		err = ssz.ErrListTooBigFn("ValidatorDutyTrace.Post", size, 13)
		return
	}
	for ii := 0; ii < len(v.Post); ii++ {
		if dst, err = v.Post[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 44 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o5, o6, o7 uint64

	// Offset (0) 'Rounds'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 44 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Decideds'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'Slot'
	v.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[8:16]))

	// Field (3) 'Role'
	v.Role = spectypes.BeaconRole(ssz.UnmarshallUint64(buf[16:24]))

	// Field (4) 'Validator'
	v.Validator = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[24:32]))

	// Offset (5) 'ProposalData'
	if o5 = ssz.ReadOffset(buf[32:36]); o5 > size || o1 > o5 {
		return ssz.ErrOffset
	}

	// Offset (6) 'Pre'
	if o6 = ssz.ReadOffset(buf[36:40]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'Post'
	if o7 = ssz.ReadOffset(buf[40:44]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Field (0) 'Rounds'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 15)
		if err != nil {
			return err
		}
		v.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if v.Rounds[indx] == nil {
				v.Rounds[indx] = new(RoundTrace)
			}
			if err = v.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'Decideds'
	{
		buf = tail[o1:o5]
		num, err := ssz.DecodeDynamicLength(buf, 256)
		if err != nil {
			return err
		}
		v.Decideds = make([]*DecidedTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if v.Decideds[indx] == nil {
				v.Decideds[indx] = new(DecidedTrace)
			}
			if err = v.Decideds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (5) 'ProposalData'
	{
		buf = tail[o5:o6]
		if len(buf) > 4194532 {
			return ssz.ErrBytesLength
		}
		if cap(v.ProposalData) == 0 {
			v.ProposalData = make([]byte, 0, len(buf))
		}
		v.ProposalData = append(v.ProposalData, buf...)
	}

	// Field (6) 'Pre'
	{
		buf = tail[o6:o7]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		v.Pre = make([]*PartialSigTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Pre[ii] == nil {
				v.Pre[ii] = new(PartialSigTrace)
			}
			if err = v.Pre[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (7) 'Post'
	{
		buf = tail[o7:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		v.Post = make([]*PartialSigTrace, num)
		for ii := 0; ii < num; ii++ {
			if v.Post[ii] == nil {
				v.Post[ii] = new(PartialSigTrace)
			}
			if err = v.Post[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) SizeSSZ() (size int) {
	size = 44

	// Field (0) 'Rounds'
	for ii := 0; ii < len(v.Rounds); ii++ {
		size += 4
		size += v.Rounds[ii].SizeSSZ()
	}

	// Field (1) 'Decideds'
	for ii := 0; ii < len(v.Decideds); ii++ {
		size += 4
		size += v.Decideds[ii].SizeSSZ()
	}

	// Field (5) 'ProposalData'
	size += len(v.ProposalData)

	// Field (6) 'Pre'
	size += len(v.Pre) * 56

	// Field (7) 'Post'
	size += len(v.Post) * 56

	return
}

// HashTreeRoot ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the ValidatorDutyTrace object with a hasher
func (v *ValidatorDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Rounds))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	// Field (1) 'Decideds'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Decideds))
		if num > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Decideds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 256)
	}

	// Field (2) 'Slot'
	hh.PutUint64(uint64(v.Slot))

	// Field (3) 'Role'
	hh.PutUint64(uint64(v.Role))

	// Field (4) 'Validator'
	hh.PutUint64(uint64(v.Validator))

	// Field (5) 'ProposalData'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(v.ProposalData))
		if byteLen > 4194532 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(v.ProposalData)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (4194532+31)/32)
	}

	// Field (6) 'Pre'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Pre))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Pre {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (7) 'Post'
	{
		subIndx := hh.Index()
		num := uint64(len(v.Post))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.Post {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ValidatorDutyTrace object
func (v *ValidatorDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the DecidedTrace object
func (d *DecidedTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DecidedTrace object to a target array
func (d *DecidedTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(52)

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, d.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, d.BeaconRoot[:]...)

	// Offset (2) 'Signers'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(d.Signers) * 8

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, d.ReceivedTime)

	// Field (2) 'Signers'
	if size := len(d.Signers); size > 13 {
		err = ssz.ErrListTooBigFn("DecidedTrace.Signers", size, 13)
		return
	}
	for ii := 0; ii < len(d.Signers); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(d.Signers[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the DecidedTrace object
func (d *DecidedTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 52 {
		return ssz.ErrSize
	}

	tail := buf
	var o2 uint64

	// Field (0) 'Round'
	d.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(d.BeaconRoot[:], buf[8:40])

	// Offset (2) 'Signers'
	if o2 = ssz.ReadOffset(buf[40:44]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 < 52 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (3) 'ReceivedTime'
	d.ReceivedTime = ssz.UnmarshallUint64(buf[44:52])

	// Field (2) 'Signers'
	{
		buf = tail[o2:]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		d.Signers = ssz.ExtendUint64(d.Signers, num)
		for ii := 0; ii < num; ii++ {
			d.Signers[ii] = spectypes.OperatorID(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DecidedTrace object
func (d *DecidedTrace) SizeSSZ() (size int) {
	size = 52

	// Field (2) 'Signers'
	size += len(d.Signers) * 8

	return
}

// HashTreeRoot ssz hashes the DecidedTrace object
func (d *DecidedTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DecidedTrace object with a hasher
func (d *DecidedTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(d.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(d.BeaconRoot[:])

	// Field (2) 'Signers'
	{
		if size := len(d.Signers); size > 13 {
			err = ssz.ErrListTooBigFn("DecidedTrace.Signers", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range d.Signers {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(d.Signers))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (3) 'ReceivedTime'
	hh.PutUint64(d.ReceivedTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DecidedTrace object
func (d *DecidedTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the RoundTrace object
func (r *RoundTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundTrace object to a target array
func (r *RoundTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(24)

	// Field (0) 'Proposer'
	dst = ssz.MarshalUint64(dst, uint64(r.Proposer))

	// Offset (1) 'ProposalTrace'
	dst = ssz.WriteOffset(dst, offset)
	if r.ProposalTrace == nil {
		r.ProposalTrace = new(ProposalTrace)
	}
	offset += r.ProposalTrace.SizeSSZ()

	// Offset (2) 'Prepares'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Prepares) * 56

	// Offset (3) 'Commits'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.Commits) * 56

	// Offset (4) 'RoundChanges'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		offset += 4
		offset += r.RoundChanges[ii].SizeSSZ()
	}

	// Field (1) 'ProposalTrace'
	if dst, err = r.ProposalTrace.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Prepares'
	if size := len(r.Prepares); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.Prepares", size, 13)
		return
	}
	for ii := 0; ii < len(r.Prepares); ii++ {
		if dst, err = r.Prepares[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Commits'
	if size := len(r.Commits); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.Commits", size, 13)
		return
	}
	for ii := 0; ii < len(r.Commits); ii++ {
		if dst, err = r.Commits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'RoundChanges'
	if size := len(r.RoundChanges); size > 13 {
		err = ssz.ErrListTooBigFn("RoundTrace.RoundChanges", size, 13)
		return
	}
	{
		offset = 4 * len(r.RoundChanges)
		for ii := 0; ii < len(r.RoundChanges); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += r.RoundChanges[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		if dst, err = r.RoundChanges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundTrace object
func (r *RoundTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 24 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3, o4 uint64

	// Field (0) 'Proposer'
	r.Proposer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'ProposalTrace'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 24 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Prepares'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Commits'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'RoundChanges'
	if o4 = ssz.ReadOffset(buf[20:24]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (1) 'ProposalTrace'
	{
		buf = tail[o1:o2]
		if r.ProposalTrace == nil {
			r.ProposalTrace = new(ProposalTrace)
		}
		if err = r.ProposalTrace.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'Prepares'
	{
		buf = tail[o2:o3]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.Prepares = make([]*QBFTTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Prepares[ii] == nil {
				r.Prepares[ii] = new(QBFTTrace)
			}
			if err = r.Prepares[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (3) 'Commits'
	{
		buf = tail[o3:o4]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.Commits = make([]*QBFTTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.Commits[ii] == nil {
				r.Commits[ii] = new(QBFTTrace)
			}
			if err = r.Commits[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}

	// Field (4) 'RoundChanges'
	{
		buf = tail[o4:]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		r.RoundChanges = make([]*RoundChangeTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if r.RoundChanges[indx] == nil {
				r.RoundChanges[indx] = new(RoundChangeTrace)
			}
			if err = r.RoundChanges[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundTrace object
func (r *RoundTrace) SizeSSZ() (size int) {
	size = 24

	// Field (1) 'ProposalTrace'
	if r.ProposalTrace == nil {
		r.ProposalTrace = new(ProposalTrace)
	}
	size += r.ProposalTrace.SizeSSZ()

	// Field (2) 'Prepares'
	size += len(r.Prepares) * 56

	// Field (3) 'Commits'
	size += len(r.Commits) * 56

	// Field (4) 'RoundChanges'
	for ii := 0; ii < len(r.RoundChanges); ii++ {
		size += 4
		size += r.RoundChanges[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the RoundTrace object
func (r *RoundTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundTrace object with a hasher
func (r *RoundTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Proposer'
	hh.PutUint64(uint64(r.Proposer))

	// Field (1) 'ProposalTrace'
	if err = r.ProposalTrace.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Prepares'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Prepares))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Prepares {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (3) 'Commits'
	{
		subIndx := hh.Index()
		num := uint64(len(r.Commits))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.Commits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (4) 'RoundChanges'
	{
		subIndx := hh.Index()
		num := uint64(len(r.RoundChanges))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.RoundChanges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundTrace object
func (r *RoundTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the RoundChangeTrace object
func (r *RoundChangeTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(r)
}

// MarshalSSZTo ssz marshals the RoundChangeTrace object to a target array
func (r *RoundChangeTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(68)

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, r.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, r.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(r.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, r.ReceivedTime)

	// Field (4) 'PreparedRound'
	dst = ssz.MarshalUint64(dst, r.PreparedRound)

	// Offset (5) 'PrepareMessages'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(r.PrepareMessages) * 56

	// Field (5) 'PrepareMessages'
	if size := len(r.PrepareMessages); size > 13 {
		err = ssz.ErrListTooBigFn("RoundChangeTrace.PrepareMessages", size, 13)
		return
	}
	for ii := 0; ii < len(r.PrepareMessages); ii++ {
		if dst, err = r.PrepareMessages[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the RoundChangeTrace object
func (r *RoundChangeTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 68 {
		return ssz.ErrSize
	}

	tail := buf
	var o5 uint64

	// Field (0) 'Round'
	r.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(r.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	r.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	r.ReceivedTime = ssz.UnmarshallUint64(buf[48:56])

	// Field (4) 'PreparedRound'
	r.PreparedRound = ssz.UnmarshallUint64(buf[56:64])

	// Offset (5) 'PrepareMessages'
	if o5 = ssz.ReadOffset(buf[64:68]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 < 68 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (5) 'PrepareMessages'
	{
		buf = tail[o5:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		r.PrepareMessages = make([]*QBFTTrace, num)
		for ii := 0; ii < num; ii++ {
			if r.PrepareMessages[ii] == nil {
				r.PrepareMessages[ii] = new(QBFTTrace)
			}
			if err = r.PrepareMessages[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the RoundChangeTrace object
func (r *RoundChangeTrace) SizeSSZ() (size int) {
	size = 68

	// Field (5) 'PrepareMessages'
	size += len(r.PrepareMessages) * 56

	return
}

// HashTreeRoot ssz hashes the RoundChangeTrace object
func (r *RoundChangeTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(r)
}

// HashTreeRootWith ssz hashes the RoundChangeTrace object with a hasher
func (r *RoundChangeTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(r.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(r.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(r.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(r.ReceivedTime)

	// Field (4) 'PreparedRound'
	hh.PutUint64(r.PreparedRound)

	// Field (5) 'PrepareMessages'
	{
		subIndx := hh.Index()
		num := uint64(len(r.PrepareMessages))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range r.PrepareMessages {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the RoundChangeTrace object
func (r *RoundChangeTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(r)
}

// MarshalSSZ ssz marshals the ProposalTrace object
func (p *ProposalTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposalTrace object to a target array
func (p *ProposalTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(64)

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, p.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, p.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, p.ReceivedTime)

	// Offset (4) 'RoundChanges'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(p.RoundChanges); ii++ {
		offset += 4
		offset += p.RoundChanges[ii].SizeSSZ()
	}

	// Offset (5) 'PrepareMessages'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.PrepareMessages) * 56

	// Field (4) 'RoundChanges'
	if size := len(p.RoundChanges); size > 13 {
		err = ssz.ErrListTooBigFn("ProposalTrace.RoundChanges", size, 13)
		return
	}
	{
		offset = 4 * len(p.RoundChanges)
		for ii := 0; ii < len(p.RoundChanges); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += p.RoundChanges[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(p.RoundChanges); ii++ {
		if dst, err = p.RoundChanges[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'PrepareMessages'
	if size := len(p.PrepareMessages); size > 13 {
		err = ssz.ErrListTooBigFn("ProposalTrace.PrepareMessages", size, 13)
		return
	}
	for ii := 0; ii < len(p.PrepareMessages); ii++ {
		if dst, err = p.PrepareMessages[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProposalTrace object
func (p *ProposalTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 64 {
		return ssz.ErrSize
	}

	tail := buf
	var o4, o5 uint64

	// Field (0) 'Round'
	p.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(p.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	p.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	p.ReceivedTime = ssz.UnmarshallUint64(buf[48:56])

	// Offset (4) 'RoundChanges'
	if o4 = ssz.ReadOffset(buf[56:60]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 64 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (5) 'PrepareMessages'
	if o5 = ssz.ReadOffset(buf[60:64]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Field (4) 'RoundChanges'
	{
		buf = tail[o4:o5]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		p.RoundChanges = make([]*RoundChangeTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if p.RoundChanges[indx] == nil {
				p.RoundChanges[indx] = new(RoundChangeTrace)
			}
			if err = p.RoundChanges[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (5) 'PrepareMessages'
	{
		buf = tail[o5:]
		num, err := ssz.DivideInt2(len(buf), 56, 13)
		if err != nil {
			return err
		}
		p.PrepareMessages = make([]*QBFTTrace, num)
		for ii := 0; ii < num; ii++ {
			if p.PrepareMessages[ii] == nil {
				p.PrepareMessages[ii] = new(QBFTTrace)
			}
			if err = p.PrepareMessages[ii].UnmarshalSSZ(buf[ii*56 : (ii+1)*56]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposalTrace object
func (p *ProposalTrace) SizeSSZ() (size int) {
	size = 64

	// Field (4) 'RoundChanges'
	for ii := 0; ii < len(p.RoundChanges); ii++ {
		size += 4
		size += p.RoundChanges[ii].SizeSSZ()
	}

	// Field (5) 'PrepareMessages'
	size += len(p.PrepareMessages) * 56

	return
}

// HashTreeRoot ssz hashes the ProposalTrace object
func (p *ProposalTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProposalTrace object with a hasher
func (p *ProposalTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(p.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(p.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(p.ReceivedTime)

	// Field (4) 'RoundChanges'
	{
		subIndx := hh.Index()
		num := uint64(len(p.RoundChanges))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range p.RoundChanges {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	// Field (5) 'PrepareMessages'
	{
		subIndx := hh.Index()
		num := uint64(len(p.PrepareMessages))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range p.PrepareMessages {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ProposalTrace object
func (p *ProposalTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the QBFTTrace object
func (q *QBFTTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(q)
}

// MarshalSSZTo ssz marshals the QBFTTrace object to a target array
func (q *QBFTTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Round'
	dst = ssz.MarshalUint64(dst, q.Round)

	// Field (1) 'BeaconRoot'
	dst = append(dst, q.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(q.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, q.ReceivedTime)

	return
}

// UnmarshalSSZ ssz unmarshals the QBFTTrace object
func (q *QBFTTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'Round'
	q.Round = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'BeaconRoot'
	copy(q.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	q.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	q.ReceivedTime = ssz.UnmarshallUint64(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the QBFTTrace object
func (q *QBFTTrace) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the QBFTTrace object
func (q *QBFTTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(q)
}

// HashTreeRootWith ssz hashes the QBFTTrace object with a hasher
func (q *QBFTTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Round'
	hh.PutUint64(q.Round)

	// Field (1) 'BeaconRoot'
	hh.PutBytes(q.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(q.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(q.ReceivedTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the QBFTTrace object
func (q *QBFTTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(q)
}

// MarshalSSZ ssz marshals the PartialSigTrace object
func (p *PartialSigTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PartialSigTrace object to a target array
func (p *PartialSigTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Type'
	dst = ssz.MarshalUint64(dst, uint64(p.Type))

	// Field (1) 'BeaconRoot'
	dst = append(dst, p.BeaconRoot[:]...)

	// Field (2) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, p.ReceivedTime)

	return
}

// UnmarshalSSZ ssz unmarshals the PartialSigTrace object
func (p *PartialSigTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 56 {
		return ssz.ErrSize
	}

	// Field (0) 'Type'
	p.Type = spectypes.PartialSigMsgType(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'BeaconRoot'
	copy(p.BeaconRoot[:], buf[8:40])

	// Field (2) 'Signer'
	p.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[40:48]))

	// Field (3) 'ReceivedTime'
	p.ReceivedTime = ssz.UnmarshallUint64(buf[48:56])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the PartialSigTrace object
func (p *PartialSigTrace) SizeSSZ() (size int) {
	size = 56
	return
}

// HashTreeRoot ssz hashes the PartialSigTrace object
func (p *PartialSigTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PartialSigTrace object with a hasher
func (p *PartialSigTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Type'
	hh.PutUint64(uint64(p.Type))

	// Field (1) 'BeaconRoot'
	hh.PutBytes(p.BeaconRoot[:])

	// Field (2) 'Signer'
	hh.PutUint64(uint64(p.Signer))

	// Field (3) 'ReceivedTime'
	hh.PutUint64(p.ReceivedTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PartialSigTrace object
func (p *PartialSigTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CommitteeDutyTrace object to a target array
func (c *CommitteeDutyTrace) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(64)

	// Offset (0) 'Rounds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Rounds); ii++ {
		offset += 4
		offset += c.Rounds[ii].SizeSSZ()
	}

	// Offset (1) 'Decideds'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Decideds); ii++ {
		offset += 4
		offset += c.Decideds[ii].SizeSSZ()
	}

	// Field (2) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(c.Slot))

	// Field (3) 'CommitteeID'
	dst = append(dst, c.CommitteeID[:]...)

	// Offset (4) 'OperatorIDs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.OperatorIDs) * 8

	// Offset (5) 'ProposalData'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.ProposalData)

	// Offset (6) 'SyncCommittee'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.SyncCommittee); ii++ {
		offset += 4
		offset += c.SyncCommittee[ii].SizeSSZ()
	}

	// Offset (7) 'Attester'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.Attester); ii++ {
		offset += 4
		offset += c.Attester[ii].SizeSSZ()
	}

	// Field (0) 'Rounds'
	if size := len(c.Rounds); size > 15 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Rounds", size, 15)
		return
	}
	{
		offset = 4 * len(c.Rounds)
		for ii := 0; ii < len(c.Rounds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Rounds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Rounds); ii++ {
		if dst, err = c.Rounds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'Decideds'
	if size := len(c.Decideds); size > 256 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Decideds", size, 256)
		return
	}
	{
		offset = 4 * len(c.Decideds)
		for ii := 0; ii < len(c.Decideds); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Decideds[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Decideds); ii++ {
		if dst, err = c.Decideds[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'OperatorIDs'
	if size := len(c.OperatorIDs); size > 13 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 13)
		return
	}
	for ii := 0; ii < len(c.OperatorIDs); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(c.OperatorIDs[ii]))
	}

	// Field (5) 'ProposalData'
	if size := len(c.ProposalData); size > 4194532 {
		err = ssz.ErrBytesLengthFn("CommitteeDutyTrace.ProposalData", size, 4194532)
		return
	}
	dst = append(dst, c.ProposalData...)

	// Field (6) 'SyncCommittee'
	if size := len(c.SyncCommittee); size > 1512 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.SyncCommittee", size, 1512)
		return
	}
	{
		offset = 4 * len(c.SyncCommittee)
		for ii := 0; ii < len(c.SyncCommittee); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.SyncCommittee[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.SyncCommittee); ii++ {
		if dst, err = c.SyncCommittee[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'Attester'
	if size := len(c.Attester); size > 1512 {
		err = ssz.ErrListTooBigFn("CommitteeDutyTrace.Attester", size, 1512)
		return
	}
	{
		offset = 4 * len(c.Attester)
		for ii := 0; ii < len(c.Attester); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.Attester[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.Attester); ii++ {
		if dst, err = c.Attester[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 64 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o4, o5, o6, o7 uint64

	// Offset (0) 'Rounds'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 64 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Decideds'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'Slot'
	c.Slot = phase0.Slot(ssz.UnmarshallUint64(buf[8:16]))

	// Field (3) 'CommitteeID'
	copy(c.CommitteeID[:], buf[16:48])

	// Offset (4) 'OperatorIDs'
	if o4 = ssz.ReadOffset(buf[48:52]); o4 > size || o1 > o4 {
		return ssz.ErrOffset
	}

	// Offset (5) 'ProposalData'
	if o5 = ssz.ReadOffset(buf[52:56]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Offset (6) 'SyncCommittee'
	if o6 = ssz.ReadOffset(buf[56:60]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'Attester'
	if o7 = ssz.ReadOffset(buf[60:64]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Field (0) 'Rounds'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 15)
		if err != nil {
			return err
		}
		c.Rounds = make([]*RoundTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Rounds[indx] == nil {
				c.Rounds[indx] = new(RoundTrace)
			}
			if err = c.Rounds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'Decideds'
	{
		buf = tail[o1:o4]
		num, err := ssz.DecodeDynamicLength(buf, 256)
		if err != nil {
			return err
		}
		c.Decideds = make([]*DecidedTrace, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Decideds[indx] == nil {
				c.Decideds[indx] = new(DecidedTrace)
			}
			if err = c.Decideds[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (4) 'OperatorIDs'
	{
		buf = tail[o4:o5]
		num, err := ssz.DivideInt2(len(buf), 8, 13)
		if err != nil {
			return err
		}
		c.OperatorIDs = ssz.ExtendUint64(c.OperatorIDs, num)
		for ii := 0; ii < num; ii++ {
			c.OperatorIDs[ii] = spectypes.OperatorID(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}

	// Field (5) 'ProposalData'
	{
		buf = tail[o5:o6]
		if len(buf) > 4194532 {
			return ssz.ErrBytesLength
		}
		if cap(c.ProposalData) == 0 {
			c.ProposalData = make([]byte, 0, len(buf))
		}
		c.ProposalData = append(c.ProposalData, buf...)
	}

	// Field (6) 'SyncCommittee'
	{
		buf = tail[o6:o7]
		num, err := ssz.DecodeDynamicLength(buf, 1512)
		if err != nil {
			return err
		}
		c.SyncCommittee = make([]*SignerData, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.SyncCommittee[indx] == nil {
				c.SyncCommittee[indx] = new(SignerData)
			}
			if err = c.SyncCommittee[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (7) 'Attester'
	{
		buf = tail[o7:]
		num, err := ssz.DecodeDynamicLength(buf, 1512)
		if err != nil {
			return err
		}
		c.Attester = make([]*SignerData, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.Attester[indx] == nil {
				c.Attester[indx] = new(SignerData)
			}
			if err = c.Attester[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) SizeSSZ() (size int) {
	size = 64

	// Field (0) 'Rounds'
	for ii := 0; ii < len(c.Rounds); ii++ {
		size += 4
		size += c.Rounds[ii].SizeSSZ()
	}

	// Field (1) 'Decideds'
	for ii := 0; ii < len(c.Decideds); ii++ {
		size += 4
		size += c.Decideds[ii].SizeSSZ()
	}

	// Field (4) 'OperatorIDs'
	size += len(c.OperatorIDs) * 8

	// Field (5) 'ProposalData'
	size += len(c.ProposalData)

	// Field (6) 'SyncCommittee'
	for ii := 0; ii < len(c.SyncCommittee); ii++ {
		size += 4
		size += c.SyncCommittee[ii].SizeSSZ()
	}

	// Field (7) 'Attester'
	for ii := 0; ii < len(c.Attester); ii++ {
		size += 4
		size += c.Attester[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CommitteeDutyTrace object with a hasher
func (c *CommitteeDutyTrace) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Rounds'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Rounds))
		if num > 15 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Rounds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 15)
	}

	// Field (1) 'Decideds'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Decideds))
		if num > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Decideds {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 256)
	}

	// Field (2) 'Slot'
	hh.PutUint64(uint64(c.Slot))

	// Field (3) 'CommitteeID'
	hh.PutBytes(c.CommitteeID[:])

	// Field (4) 'OperatorIDs'
	{
		if size := len(c.OperatorIDs); size > 13 {
			err = ssz.ErrListTooBigFn("CommitteeDutyTrace.OperatorIDs", size, 13)
			return
		}
		subIndx := hh.Index()
		for _, i := range c.OperatorIDs {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(c.OperatorIDs))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(13, numItems, 8))
	}

	// Field (5) 'ProposalData'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.ProposalData))
		if byteLen > 4194532 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.ProposalData)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (4194532+31)/32)
	}

	// Field (6) 'SyncCommittee'
	{
		subIndx := hh.Index()
		num := uint64(len(c.SyncCommittee))
		if num > 1512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.SyncCommittee {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1512)
	}

	// Field (7) 'Attester'
	{
		subIndx := hh.Index()
		num := uint64(len(c.Attester))
		if num > 1512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.Attester {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1512)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CommitteeDutyTrace object
func (c *CommitteeDutyTrace) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the SignerData object
func (s *SignerData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignerData object to a target array
func (s *SignerData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Field (0) 'Signer'
	dst = ssz.MarshalUint64(dst, uint64(s.Signer))

	// Offset (1) 'ValidatorIdx'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.ValidatorIdx) * 8

	// Field (2) 'ReceivedTime'
	dst = ssz.MarshalUint64(dst, s.ReceivedTime)

	// Field (1) 'ValidatorIdx'
	if size := len(s.ValidatorIdx); size > 1000 {
		err = ssz.ErrListTooBigFn("SignerData.ValidatorIdx", size, 1000)
		return
	}
	for ii := 0; ii < len(s.ValidatorIdx); ii++ {
		dst = ssz.MarshalUint64(dst, uint64(s.ValidatorIdx[ii]))
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SignerData object
func (s *SignerData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Signer'
	s.Signer = spectypes.OperatorID(ssz.UnmarshallUint64(buf[0:8]))

	// Offset (1) 'ValidatorIdx'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 20 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (2) 'ReceivedTime'
	s.ReceivedTime = ssz.UnmarshallUint64(buf[12:20])

	// Field (1) 'ValidatorIdx'
	{
		buf = tail[o1:]
		num, err := ssz.DivideInt2(len(buf), 8, 1000)
		if err != nil {
			return err
		}
		s.ValidatorIdx = make([]phase0.ValidatorIndex, num)
		for ii := 0; ii < num; ii++ {
			s.ValidatorIdx[ii] = phase0.ValidatorIndex(ssz.UnmarshallUint64(buf[ii*8 : (ii+1)*8]))
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SignerData object
func (s *SignerData) SizeSSZ() (size int) {
	size = 20

	// Field (1) 'ValidatorIdx'
	size += len(s.ValidatorIdx) * 8

	return
}

// HashTreeRoot ssz hashes the SignerData object
func (s *SignerData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignerData object with a hasher
func (s *SignerData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Signer'
	hh.PutUint64(uint64(s.Signer))

	// Field (1) 'ValidatorIdx'
	{
		if size := len(s.ValidatorIdx); size > 1000 {
			err = ssz.ErrListTooBigFn("SignerData.ValidatorIdx", size, 1000)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.ValidatorIdx {
			hh.AppendUint64(uint64(i))
		}
		hh.FillUpTo32()
		numItems := uint64(len(s.ValidatorIdx))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1000, numItems, 8))
	}

	// Field (2) 'ReceivedTime'
	hh.PutUint64(s.ReceivedTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignerData object
func (s *SignerData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the DiskMsg object
func (d *DiskMsg) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DiskMsg object to a target array
func (d *DiskMsg) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(17)

	// Offset (0) 'Signed'
	dst = ssz.WriteOffset(dst, offset)
	offset += d.Signed.SizeSSZ()

	// Offset (1) 'Spec'
	dst = ssz.WriteOffset(dst, offset)
	offset += d.Spec.SizeSSZ()

	// Field (2) 'Kind'
	dst = ssz.MarshalUint8(dst, d.Kind)

	// Offset (3) 'Qbft'
	dst = ssz.WriteOffset(dst, offset)
	offset += d.Qbft.SizeSSZ()

	// Offset (4) 'Sig'
	dst = ssz.WriteOffset(dst, offset)
	offset += d.Sig.SizeSSZ()

	// Field (0) 'Signed'
	if dst, err = d.Signed.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Spec'
	if dst, err = d.Spec.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'Qbft'
	if dst, err = d.Qbft.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'Sig'
	if dst, err = d.Sig.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the DiskMsg object
func (d *DiskMsg) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 17 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o3, o4 uint64

	// Offset (0) 'Signed'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 17 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Spec'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'Kind'
	d.Kind = ssz.UnmarshallUint8(buf[8:9])

	// Offset (3) 'Qbft'
	if o3 = ssz.ReadOffset(buf[9:13]); o3 > size || o1 > o3 {
		return ssz.ErrOffset
	}

	// Offset (4) 'Sig'
	if o4 = ssz.ReadOffset(buf[13:17]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (0) 'Signed'
	{
		buf = tail[o0:o1]
		if err = d.Signed.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Spec'
	{
		buf = tail[o1:o3]
		if err = d.Spec.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (3) 'Qbft'
	{
		buf = tail[o3:o4]
		if err = d.Qbft.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (4) 'Sig'
	{
		buf = tail[o4:]
		if err = d.Sig.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DiskMsg object
func (d *DiskMsg) SizeSSZ() (size int) {
	size = 17

	// Field (0) 'Signed'
	size += d.Signed.SizeSSZ()

	// Field (1) 'Spec'
	size += d.Spec.SizeSSZ()

	// Field (3) 'Qbft'
	size += d.Qbft.SizeSSZ()

	// Field (4) 'Sig'
	size += d.Sig.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the DiskMsg object
func (d *DiskMsg) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DiskMsg object with a hasher
func (d *DiskMsg) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Signed'
	if err = d.Signed.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Spec'
	if err = d.Spec.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Kind'
	hh.PutUint8(d.Kind)

	// Field (3) 'Qbft'
	if err = d.Qbft.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'Sig'
	if err = d.Sig.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DiskMsg object
func (d *DiskMsg) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}
